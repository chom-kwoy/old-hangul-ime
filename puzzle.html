<!doctype html>
<!-- WebGL로 구현한 15 Puzzle 게임 -->
<html>

<head>
<title>15 Puzzle Game</title>
<meta charset="utf-8">

<!-- 버텍스 셰이더 -->
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec4 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying vec2 vTextureCoord;
    varying float vDepth;

    void main(void) {
        vTextureCoord = aTextureCoord;
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        vDepth = gl_Position.z / gl_Position.w;
    }
</script>

<!-- 프래그먼트 셰이더 -->
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    // 텍스처
    uniform sampler2D uSampler;

    // 텍스처에 추가로 입힐 색상
    uniform vec4 uTint;

    // 텍스처 좌표
    varying vec2 vTextureCoord;

    // 깊이 값
    varying float vDepth;

    void main(void) {
        gl_FragColor = texture2D(uSampler, vTextureCoord) + uTint;
        
        // 깊이를 주기 위해 안쪽으로 들어갈수록 어둡게 처리
        gl_FragColor.rgb *= pow(smoothstep(0.4, 0.01, vDepth), 10.0);
    }
</script>

<script type="text/javascript">

  // OpenGL 컨텍스트
  var gl;
  
  // 캔버스에서 OpenGL 컨텍스트를 받아온다.
  function initGL(canvas) {
    try {
      gl = canvas.getContext("experimental-webgl");
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
    } catch(e) {
    }
    if (!gl) {
      alert("Could not initialize WebGL");
    }
  }

  // 셰이더 컴파일하기
  function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) return null;

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
      if (k.nodeType == 3) str += k.textContent;
      k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert(gl.getShaderInfoLog(shader));
      return null;
    }

    return shader;
  }

  // 셰이더
  var shader;
  
  // 애트리뷰트
  var attribute = {};
  
  // 유니폼
  var uniform = {};
  
  // 컴파일된 셰이더에서 애트리뷰트와 유니폼 위치를 받아온다.
  function initShaders() {

    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");

    shader = gl.createProgram();
    gl.attachShader(shader, vertexShader);
    gl.attachShader(shader, fragmentShader);
    gl.linkProgram(shader);

    if (!gl.getProgramParameter(shader, gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shader);

    attribute.aVertexPosition = gl.getAttribLocation(shader, "aVertexPosition");
    gl.enableVertexAttribArray(attribute.aVertexPosition);
    attribute.aTextureCoord = gl.getAttribLocation(shader, "aTextureCoord");
    gl.enableVertexAttribArray(attribute.aTextureCoord);

    uniform.uSampler = gl.getUniformLocation(shader, "uSampler");
    uniform.uProjectionMatrix = gl.getUniformLocation(shader, 'uProjectionMatrix');
    uniform.uModelViewMatrix = gl.getUniformLocation(shader, 'uModelViewMatrix');
    uniform.uTint = gl.getUniformLocation(shader, 'uTint');
  }

  var buffer = {};
  // 버퍼 초기화
  function initBuffers() {
    // vertex buffer
    buffer.cube = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer.cube);
    const vertices = [-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,
                      -1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,
                      -1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,
                      -1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(attribute.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

    // texture coordiantes
    buffer.textcoords = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer.textcoords);
    const textureCoordinates = [
        0, 1, 1, 1, 1, 0, 0, 0,
        0, 1, 0, 0, 1, 0, 1, 1,
        0, 0, 0, 1, 1, 1, 1, 0,
        0, 1, 1, 1, 1, 0, 0, 0,
        1, 1, 1, 0, 0, 0, 0, 1,
        0, 1, 1, 1, 1, 0, 0, 0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
    gl.vertexAttribPointer(attribute.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

    // indices buffer
    buffer.indices = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer.indices);
    const indices = [
        0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7,
        8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15,
        16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  }

  var texture = [];
  // 텍스처 (A - O) 초기화
  function initTextures() {
    for (let i = 1; i <= 16; ++i) {
        // 우선 회색 1x1 텍스처로 초기화해 놓고 천천히 불러온다.
        texture[i] = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture[i]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([200, 200, 200, 255]));

        const image = new Image();
        image.onload = function() {
            gl.bindTexture(gl.TEXTURE_2D, texture[i]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        };
        image.src = i + ".gif";
    }
  }

  // x 축을 중심으로 회전하는 변환행렬
  function rotateX(x) {
    return [1, 0, 0, 0,
            0, Math.cos(x), -Math.sin(x), 0,
            0, Math.sin(x), Math.cos(x), 0,
            0, 0, 0, 1];
  }

  // y축을 중심으로 회전
  function rotateY(x) {
    return [Math.cos(x), 0, Math.sin(x), 0,
            0, 1, 0, 0,
            -Math.sin(x), 0, Math.cos(x), 0,
            0, 0, 0, 1];
  }

  // z축을 중심으로 회전
  function rotateZ(x) {
    return [Math.cos(x), -Math.sin(x), 0, 0,
            Math.sin(x), Math.cos(x), 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1];
  }

  // x, y, z만큼 평행이동
  function translate(x, y, z) {
    return [1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1];
  }

  // x, y, z만큼 확대/축소
  function scale(x, y, z) {
    return [x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1];
  }

  // 행렬곱셈
  function mul(A, B) {
    let mat = [0, 0, 0, 0,
               0, 0, 0, 0,
               0, 0, 0, 0,
               0, 0, 0, 0]
    for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
            for (let k = 0; k < 4; ++k) {
                mat[i*4+j] += A[i*4+k] * B[k*4+j];
            }
        }
    }
    return mat;
  }

  // 전치행렬
  function trans(mat) {
    for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < i; ++j) {
            let t = mat[i*4+j];
            mat[i*4+j] = mat[j*4+i];
            mat[j*4+i] = t;
        }
    }
    return mat;
  }

  const PI = 3.141592653589793238;

  // 움직이는 효과 시작 프레임
  var anim_start;
  
  // 효과가 적용되고 있는 블럭
  var anim_idx;
  
  // 어느 방향으로 이동 중인지
  var anim_dir;
  
  // 몇 프레임동안 효과를 보여줄건지
  var anim_dur = 10;
  
  // 마우스 위에 댔을 때 나오는 효과
  var anim_hover;

  var frame = 0;
  // 화면 렌더링
  function drawScene() {
    gl.enable(gl.DEPTH_TEST);
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.activeTexture(gl.TEXTURE0);

    for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
            var n = puzzles[i * 4 + j];
            if (n == 16) continue;

            gl.bindTexture(gl.TEXTURE_2D, texture[n]);
            gl.uniform1i(uniform.uSampler, 0);

            if (anim_hover == n) {
                gl.uniform4f(uniform.uTint, 0, 0.5, 0, 0);
            }
            else {
                gl.uniform4f(uniform.uTint, 0, 0, 0, 0);
            }

            let mat = translate(0, 0, 0);
            mat = mul(mat, translate(-3/4 + 1/2 * j, 3/4 - 1/2 * i, 0));
            if (anim_idx == n && anim_start + anim_dur > frame) {
                let p = (frame - anim_start) / anim_dur;
                p = (Math.tanh((p - 0.5) * 5) + 1) / 2;

                // left
                if (anim_dir == 0)
                {
                    mat = mul(mat, translate(-1/2 + 1/2 * p, 0, 0));
                    mat = mul(mat, rotateY(PI / 2 * p));
                }

                // right
                if (anim_dir == 1)
                {
                    mat = mul(mat, translate(1/2 - 1/2 * p, 0, 0));
                    mat = mul(mat, rotateY(-PI / 2 * p));
                }

                // down
                if (anim_dir == 2) {
                    mat = mul(mat, translate(0, 1/2 - 1/2 * p, 0));
                    mat = mul(mat, rotateX(PI / 2 * p));
                }

                // up
                if (anim_dir == 3) {
                    mat = mul(mat, translate(0, -1/2 + 1/2 * p, 0));
                    mat = mul(mat, rotateX(-PI / 2 * p));
                }
            }
            mat = mul(mat, scale(1/5, 1/5, 1/5));
            gl.uniformMatrix4fv(uniform.uModelViewMatrix, false, trans(mat));

            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        }
    }

    frame++;
  }

// 초기 상태
var puzzles=new Array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);
var completed=true; // 퍼즐이 완성되었는지에 대한 여부

  function webGLStart() {
    let canvas = document.getElementById("canvas");
    // 클릭했을 때
    canvas.addEventListener('click', function(event) {
        let x = Math.floor((event.pageX - canvas.offsetLeft) / canvas.offsetWidth * 4),
            y = Math.floor((event.pageY - canvas.offsetTop) / canvas.offsetHeight * 4);
        let idx = puzzles[y * 4 + x];
        movePiece(idx);
    }, false);
    // 마우스 움직였을 때
    canvas.addEventListener('mousemove', function(event) {
        let x = Math.floor((event.pageX - canvas.offsetLeft) / canvas.offsetWidth * 4),
            y = Math.floor((event.pageY - canvas.offsetTop) / canvas.offsetHeight * 4);
        let idx = puzzles[y * 4 + x];
        anim_hover = idx;
    }, false);
    // 마우스 나갔을 때
    canvas.addEventListener('mouseout', function(event) {
        anim_hover = undefined;
    }, false);
    initGL(canvas);
    initShaders();
    initBuffers();
    initTextures();

    // 카메라 세팅
    const r = 0.55, t = 0.55, l = -r, b = -t, f = 10, n = 1;
    gl.uniformMatrix4fv(uniform.uProjectionMatrix, false, 
        trans(mul(
              [2*n/(r-l), 0, 0, 0,
               0, 2*n/(t-b), 0, 0,
               (r+l)/(r-l), (t+b)/(t-b), -(f+n)/(f-n), -1,
               0, 0, -2*f*n/(f-n), 0],
               translate(0, 0, -1))));

    gl.clearColor(0.0, 0.0, 0.0, 0.0);

    // 15ms마다 화면 그리기
    setInterval(drawScene, 15);
  }

// 문자열(str)을 구분자(sep)로 끊은 토큰들의 리스트를 생성
// sep: 구분자(seprator)
function tokenize(sep,str)
{
  tokens = new Array(); // 토큰 리스트
  
  i=0;
  while(1)
  {
     idx=str.indexOf(sep);
     if(idx == -1)
     {
          if(str.length>0)
          {
              tokens[i]=str;
          } 
          break;
     }
     tokens[i++]=str.substring(0,idx); // 새로운 토큰 추가
     str=str.substr(idx+1); // 다음 토큰을 찾을 문자열
  }
  return tokens;
}

// 퍼즐판에서의 x 좌표
function getX(idx)
{
  var rest=idx-Math.floor(idx/4)*4; 
  return (rest==0)?4:rest;
}

// 퍼즐판에서의 y 자표
function getY(idx)
 {
    return Math.floor((idx-1)/4)+1;
 }

// 퍼즐판에서의 좌표(x,y)가 몇 번째 칸인지를 계산
function getIndex(x,y)
 {
   return x+(y-1)*4;
 }

// x(혹은 y) 좌표를 입력받아 이동할 수 있는 새로운 좌표를 구함
function newDirection(pos)
{
  var dir;

  if ((pos==2)||(pos==3)) dir=(Math.floor(Math.random()+0.5)==0)?-1:1;
  else dir=(pos==1)?1:-1;
  return (pos+dir);
}

// 퍼즐 조각이 새로 이동할 수 있는 칸을 계산
function newIndex(idx)
{
  var x,y;

  x=getX(idx);
  y=getY(idx);
  if (Math.floor(Math.random()+0.5)==0) x=newDirection(x);
  else y=newDirection(y);
  return getIndex(x,y);
}

// 퍼즐이 완성되었는지에 대한 여부
function isComplete()
{
  // 배열 document.images[]의 원소들(각 원소에 할당된 퍼즐 조각 그림들)이 오름차순으로 차례대로 정렬되어 있고
  // completed 가 false이면,
  // 퍼즐이 완성된 것이다.
  if(completed) return false;
  for (var i = 1; i <= 16; ++i) {
    if (puzzles[i - 1] != i) return false;
  }
  return true;
}

// random int in [min, max] range
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// 퍼즐을 섞음
function shuffle()
 {
  puzzles = new Array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);

  // iter: 퍼즐 조각을 섞는 횟수
  iter=Math.floor(Math.random()*200+0.5)+100;
  // puzzles 배열의 원소들을 섞는다.
  for (let i=1;i<iter;i++)
  {
    let idx = getRandomInt(1, 16);
    let nidx = newIndex(idx);
    let t = puzzles[idx - 1];
    puzzles[idx - 1] = puzzles[nidx - 1];
    puzzles[nidx - 1] = t;
    // puzzles[] 배열의 임의로 선택된 퍼즐판상에서의 인접한 두 퍼즐조각을 서로 바꾼다.
  }
  
  // 퍼즐을 섞으면 게임이 새로 시작되므로 completed 변수를 false로 초기화
  completed = false;
}

// 퍼즐 조각을 이동
function movePiece(idx)
{
    // 퍼즐판에서 idx 번째 칸에 있는 퍼즐조각에 대한 퍼즐 조각 번호를 얻어낸다.
    // 만약 그 번호가 16이면 blank를 의미하므로 더 이상의 작업이 필요없다.

    // x: 선택된 퍼즐 조각의 퍼즐판상에서의 x 좌표
    // y: 선택된 퍼즐 조각의 퍼즐판상에서의 y 좌표
    // flag: 이동이 가능하면 1, 아니면 0
    // midx: 이동가능한 칸의 번호

    // 선택된 퍼즐 조각의 상하좌우 방향으로 바로 인접한 칸에 대하여
    // 비어있는 칸을 찾는다(해당 칸의 퍼즐조각 번호가 16이면 비어있는 칸).

    // 비어있는 칸이 존재하면
    // 선택된 칸의 퍼즐 조각을 그 칸으로 이동시킨다.

    // 퍼즐이 완성되었는지 확인하여
    // 퍼즐이 완성된 상태면,
    // "Congratulation!" 메시지를 경고창(alert box)으로 띄어주고 completed 변수를 true로 세팅한다.
    let x, y;
    let flag = false;
    let midx;

    for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
            if (puzzles[i*4+j] == idx) {
                x = i;
                y = j;
                flag = true;
                if (i < 3 && puzzles[(i+1)*4+j] == 16)
                    midx = (i+1)*4+j, anim_dir = 2;
                else if (i > 0 && puzzles[(i-1)*4+j] == 16)
                    midx = (i-1)*4+j, anim_dir = 3;
                else if (j < 3 && puzzles[i*4+j+1] == 16)
                    midx = i*4+j+1, anim_dir = 0;
                else if (j > 0 && puzzles[i*4+j-1] == 16)
                    midx = i*4+j-1, anim_dir = 1;
                else
                    flag = false;
                break;
            }
        }
        if (flag) break;
    }

    // 움직일 수 있으면 업데이트
    if (flag) {
        puzzles[x*4+y] = 16;
        puzzles[midx] = idx;  

        anim_start = frame;
        anim_idx = idx;
        anim_hover = undefined;
    }

    // 퍼즐이 완성되었으면 congratulations 출력
    if (isComplete()) {
        completed = true;
        alert("Congratulations!");
    }
}
</script>

<style>
    body {
        background-color: #EEE;
    }
    h1 {
        text-align: center;
    }
    canvas, button {
        display: block;
        margin: 0 auto 10px;
    }

    canvas {
        outline: 1px solid black;
    }
</style>
</head>

<body onload="webGLStart();">
    <h1>15 Puzzle Game</h1>
    <canvas id="canvas" width="500" height="500" ></canvas>
    <button onclick="shuffle()">시작</button>
</body>

</html>
